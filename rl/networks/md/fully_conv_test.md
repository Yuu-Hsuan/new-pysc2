```
rom collections import namedtuple

import tensorflow as tf
import numpy as np

from pysc2.lib.features import FeatureType, colors

from rl.networks.fully_conv import FullyConv


class FullyConvTest(tf.test.TestCase):
# 定義了一個測試用class，繼承自 tf.test.TestCase，用於測試 TensorFlow 模型的功能。
  
  def test_embed_obs(self):
  # 測試 FullyConv 類中的 embed_obs 方法是否正確。
  # 這是一個測試 FullyConv 類別中 embed_obs 功能的程式。
  # 我們要測試這段功能是否能「看懂遊戲中的資料」，並把它轉換成適合機器學習模型的語言。
    
    MyFeature = namedtuple('MyFeature', ['index', 'scale', 'type'])
    # 創建名為 MyFeature 的 namedtuple，用來描述: 特徵的索引、縮放比例（scale）以及類型（type）。
    """
    這裡我們創建了一種「小紙條」，每張紙條記錄了遊戲中的某一類資訊：

    index：這個特徵的順序，像是遊戲中的第幾種資料。
    scale：特徵的範圍（最大值），例如地圖可能有 256 種不同地形。
    type：特徵的類型，是「數字」還是「分類」（例如：金礦的數量 vs. 地圖上的地形類型）。
    """
    net = FullyConv()
    # 叫出FullyConv來分析遊戲資料的 AI。
    
    spec_lst = [
        (256, FeatureType.SCALAR),
        (4, FeatureType.CATEGORICAL),
        (2, FeatureType.SCALAR),# 數字型資料，金礦數量
        (2, FeatureType.CATEGORICAL),# 類別型資料，單位狀態。
    ]# 定義特徵規範列表，其中包含每個特徵的縮放範圍和類型（標量或類別型）。
    """
    256 種不同的地形數據（標量類型，像是高度）。
    4 種地形分類（像是岩石、草地、水域、沙地）。
    2 金礦的數量，範圍是 0 到 2（標量類型）。
    2 單位的狀態（分類數據，例如：移動中、閒置中）。

    """
    
    spec = [MyFeature(i, *t) for i, t in enumerate(spec_lst)]
    # 將 spec_lst 轉換為 MyFeature 類型的列表，每個特徵附帶索引。
    
    embed_fn = lambda x, dims: x
    # 定義了一個嵌入函數（embed_fn），在此測試中直接返回輸入數據。目的是讓測試更簡單。
   
    x = np.array([
        [112, 3, 0, 1],# 112 代表高地的高度。3 代表地形類型是岩石
        [22, 1, 1, 0],
        [0, 0, 0, 0],
        [255, 2, 1, 1]], dtype=np.float32)
    # 定義輸入數據矩陣，模擬一組特徵值，用於測試。
    # 每一行模擬一個地圖上的「地點」，包含該地點的地形、資源和單位狀態資訊。
    # 第 1 行：高地數值是 112，地形類型是 3（金礦數量是 0，單位狀態是 1）。
    # 第 2 行：高地數值是 22，地形類型是 1。
    # 第 3 行: 代表一個空白或無特徵的地區。
    # 第 4 行: 代表一個戰略價值高的地區，有金礦且地形特殊（例如高地或障礙物）。
     """
    第 3 行 [0, 0, 0, 0]：
    高地數值（第一列）：0，表示該地區的高度是最低的，可能是平地或水域。
    地形類型（第二列）：0，表示該地區可能是未定義地形或預設的基本地形（例如空白區域或無效區域）。
    金礦數量（第三列）：0，表示該地區沒有金礦可用。
    單位狀態（第四列）：0，表示該地區可能沒有單位或單位處於閒置狀態。
    這行可能模擬了一個「無特徵」的地區，例如地圖邊界或沒有任何遊戲物件的地方。
    第 4 行 [255, 2, 1, 1]：
    高地數值（第一列）：255，表示該地區的高度是最大值，可能是山頂或不可通行的高地。
    地形類型（第二列）：2，表示該地區的地形類型可能是「水域」或某種特殊地形。
    金礦數量（第三列）：1，表示該地區有一個金礦可用。
    單位狀態（第四列）：1，表示該地區的單位處於某種活動狀態（例如：移動中或建造中）。
    這行可能模擬了一個資源豐富但難以到達的高地地區，代表遊戲中的重要目標區域。
    """   
    results = net.embed_obs(x, spec, embed_fn)
    # 調用 FullyConv 的 embed_obs 方法，對輸入數據 x 進行嵌入操作，返回結果 results

    expected_results = np.array([
        [1.5040774,    0, 0, 0, 1,    0,             0, 1],
        [0.52324814,   0, 1, 0, 0,    1.60943791,    1, 0],
        [0.0,          1, 0, 0, 0,    0,             1, 0],
        [2.19374631,   0, 0, 1, 0,    1.60943791,    0, 1]], dtype=np.float32)
    # 定義期望的輸出數據，用於與實際結果進行比較。
    """
    這是我們期望的結果：
    標量數據（像高地）經過「壓縮」（例如對數運算）後，變得更容易理解。
    分類數據（像地形類型）被轉換成「One-Hot 編碼」將不同類型轉換成易於辨識的形式。
    第一行 [1.5040774, 0, 0, 0, 1, 0, 0, 1]：

    高地數值 112 的對數嵌入結果 → 1.5040774。
    地形類型 3 的 One-Hot 編碼 → [0, 0, 0, 1]。
    金礦數量 0 的對數嵌入結果 → 0。
    單位狀態 1 的 One-Hot 編碼 → [0, 1]。
    第二行 [0.52324814, 0, 1, 0, 0, 1.60943791, 1, 0]：

    高地數值 22 的對數嵌入結果 → 0.52324814。
    地形類型 1 的 One-Hot 編碼 → [0, 1, 0, 0]。
    金礦數量 1 的對數嵌入結果 → 1.60943791。
    單位狀態 0 的 One-Hot 編碼 → [1, 0]。
    第三行 [0.0, 1, 0, 0, 0, 0, 1, 0]：

    高地數值 0 的對數嵌入結果 → 0.0。
    地形類型 0 的 One-Hot 編碼 → [1, 0, 0, 0]。
    金礦數量 0 的對數嵌入結果 → 0。
    單位狀態 0 的 One-Hot 編碼 → [1, 0]。
    第四行 [2.19374631, 0, 0, 1, 0, 1.60943791, 0, 1]：

    高地數值 255 的對數嵌入結果 → 2.19374631。
    地形類型 2 的 One-Hot 編碼 → [0, 0, 1, 0]。
    金礦數量 1 的對數嵌入結果 → 1.60943791。
    單位狀態 1 的 One-Hot 編碼 → [0, 1]。
    
    """
    
    with self.test_session() as sess:
      results_out, = sess.run([results])
      self.assertAllClose(results_out, expected_results)
    # 啟動 TensorFlow 的測試會話（test_session），運行 results 並與期望結果進行比較，確保輸出精度。

if __name__ == '__main__':
  tf.test.main()
# 作為主程序入口，執行所有測試用例。

"""
主要是对 FullyConv 类中的 embed_obs 方法进行单元测试，验证它的功能是否按照预期运作。
这段代码构建了一个完整的单元测试框架，专注于验证 FullyConv 类中 embed_obs 的特征嵌入逻辑。
测试严格控制输入和期望输出，确保代码的功能性和可靠性，是深度学习模型开发中的关键步骤之一
1. embed_obs 的工作原理
遍历每个特征，根据其类型进行不同的处理：
标量型特征：对数变换，增强小值的影响。
类别型特征：将其转化为 one-hot 编码。
最终，将所有特征嵌入结果拼接为一个张量。
2. 测试逻辑
通过定义特征规格、输入数据和期望输出，验证 embed_obs 方法是否能够正确处理不同类型的特征。
确保数值计算和特征嵌入逻辑的正确性。
运行结果
如果 embed_obs 方法的输出和期望结果匹配，则测试通过，表明功能实现正确。
如果输出与期望不符，测试会报错，提示需要检查代码逻辑。

"""
```
